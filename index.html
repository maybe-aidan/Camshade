<!DOCTYPE html>
<html>
<head>
  <title>Webcam Shader</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
    <div id="controls">
        <label for="shaders">Select Shader</label>
        <select name="shaders" id="shaders">
            <option value="fragment">Default</option>
            <option value="sketch">Sketch</option>
            <option value="comic">Comic</option>
            <option value="ascii">Ascii</option>
        </select>
        <button id="save-frame">Save Frame</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const video = document.createElement('video');
        navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
            video.srcObject = stream;
            video.play();
            video.addEventListener('loadedmetadata', () => {
                adjustAspectRatio();
            });
        });

        async function loadShaderFile(url) {
            const response = await fetch(url);
            return response.text();
        }

        let quad; // Declare `quad` here for global access

        const start = Date.now();
        let currentShader = 'fragment';

        async function init() {
            const vertexShaderSource = await loadShaderFile('./shaders/vertex.glsl?v=' + Date.now());
            const fragmentShaderSource = await loadShaderFile(`./shaders/${currentShader}.glsl?v=` + Date.now());

            const texture = new THREE.VideoTexture(video);
            const font = new THREE.TextureLoader().load("./textures/font1.png");
            const noise = new THREE.TextureLoader().load("./textures/gray_noise_small.png");

            const resolution = [window.innerWidth, window.innerHeight];

            const material = new THREE.ShaderMaterial({
                uniforms: { 
                    u_texture: { value: texture }, 
                    u_font: { value: font },
                    u_noise: { value: noise },
                    u_resolution: { value: resolution },
                    u_time: { value: 0.0 }
                },
                vertexShader: vertexShaderSource,
                fragmentShader: fragmentShaderSource,
            });

            const plane = new THREE.PlaneGeometry(2, 2);

            // Remove the old quad if it exists
            if (quad) {
                scene.remove(quad);
                quad.geometry.dispose(); // Dispose the geometry
                quad.material.dispose(); // Dispose the material
            }

            quad = new THREE.Mesh(plane, material);
            scene.add(quad);

            adjustAspectRatio(); // Ensure aspect ratio is adjusted after `quad` is created
        }


        function animate() {
            requestAnimationFrame(animate);

            if(quad && quad.material.uniforms.u_time) {
                quad.material.uniforms.u_time.value = (Date.now() - start)/1000.0;
            }

            renderer.render(scene, camera);
        }

        // Handle resizing and maintain aspect ratio
        function adjustAspectRatio() {
            if (!quad) return; // Ensure `quad` is initialized

            const videoAspect = video.videoWidth / video.videoHeight;
            const windowAspect = window.innerWidth / window.innerHeight;

            if (windowAspect > videoAspect) {
                // Window is wider than the video
                const scaleX = videoAspect / windowAspect;
                quad.scale.set(scaleX, 1, 1);
            } else {
                // Window is taller than the video
                const scaleY = windowAspect / videoAspect;
                quad.scale.set(1, scaleY, 1);
            }

            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.updateProjectionMatrix();
        }

        async function changeShader(newShader) {
            currentShader = newShader;
            await init(); // Reinitialize the shader with the new fragment shader
        }

        document.getElementById('shaders').addEventListener('change', (event) => {
            changeShader(event.target.value);
        });

        window.addEventListener('resize', adjustAspectRatio);

        document.getElementById('save-frame').addEventListener('click', () => {
            // Explicitly render the scene to ensure the canvas has the latest frame
            renderer.render(scene, camera);
            
            // Save the current frame
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = 'snapshot.png';
            link.href = dataURL;
            link.click();
        });

        init();
        animate();
    </script>
</body>
</html>